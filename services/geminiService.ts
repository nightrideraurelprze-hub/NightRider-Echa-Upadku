import { GoogleGenAI, Type } from "@google/genai";
import type { PanelPromptData, PanelData } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const panelSchema = {
  type: Type.OBJECT,
  properties: {
    text: {
      type: Type.STRING,
      description: "The short, narrative text for this single comic book panel. Should be 1-3 sentences long."
    },
    imagePrompt: {
      type: Type.STRING,
      description: "A highly detailed, cinematic, and photorealistic prompt for an image generator (like Imagen) to create a visual for this specific panel. Describe the scene, characters, lighting, and mood. Specify 16:9 aspect ratio."
    },
    soundscapePrompt: {
      type: Type.STRING,
      description: "A short prompt for a text generator to describe the atmospheric sounds of this specific panel in one sentence."
    }
  },
  required: ["text", "imagePrompt", "soundscapePrompt"]
};

/**
 * Splits a long story text into structured comic book panels using the Gemini API.
 * @param storyText The full text of the story.
 * @returns A promise that resolves to an array of panel prompt data.
 */
export const generateStoryPanels = async (storyText: string): Promise<PanelPromptData[]> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: `Analyze the following post-apocalyptic story and break it down into a series of distinct, sequential comic book panels. For each panel, provide a short narrative text, a detailed image prompt, and a brief soundscape prompt. Ensure the panels logically follow the story's progression. Here is the story: ${storyText}`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            panels: {
              type: Type.ARRAY,
              items: panelSchema,
            },
          },
        },
      },
    });

    const jsonText = response.text.trim();
    const parsed = JSON.parse(jsonText);
    return parsed.panels;
  } catch (error) {
    console.error("Error generating story panels:", error);
    throw new Error("Failed to deconstruct the story into panels.");
  }
};


/**
 * Generates an image based on a textual prompt using the Imagen model.
 * @param prompt The text prompt to generate an image from.
 * @returns A promise that resolves to a base64 data URL of the generated image.
 */
export const generatePostApocalypticImage = async (prompt: string): Promise<string> => {
  try {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        outputMimeType: 'image/png',
        aspectRatio: '16:9',
      },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
      const base64ImageBytes = response.generatedImages[0].image.imageBytes;
      return `data:image/png;base64,${base64ImageBytes}`;
    } else {
      throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    console.error("Error generating image:", error);
    return "https://picsum.photos/1920/1080?grayscale&blur=2"; // Placeholder on error
  }
};

/**
 * Generates descriptive text based on a prompt using the Gemini Flash model.
 * @param prompt The text prompt for the AI.
 * @returns A promise that resolves to the generated text.
 */
export const generateAtmosphericText = async (prompt: string): Promise<string> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });
    return response.text;
  } catch (error) {
    console.error("Error generating atmospheric text:", error);
    return "The air is thick with a silence that is heavier than sound. Only the ghosts of the old world whisper on the wind.";
  }
};

/**
 * Translates the textual content of comic book panels to a target language.
 * @param panels The array of panel data to translate.
 * @param targetLanguage The target language (e.g., "English", "Polish").
 * @returns A promise that resolves to an array of translated panel data.
 */
export const translatePanels = async (panels: PanelData[], targetLanguage: string): Promise<PanelData[]> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: `Translate the 'text' and 'soundscape' fields for each object in the following JSON array into ${targetLanguage}. Do not translate any other fields. Maintain the original JSON structure. Here is the data: ${JSON.stringify(panels)}`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              text: { type: Type.STRING },
              imageUrl: { type: Type.STRING },
              soundscape: { type: Type.STRING },
            },
          },
        },
      },
    });

    const jsonText = response.text.trim();
    return JSON.parse(jsonText);
  } catch (error) {
    console.error(`Error translating panels to ${targetLanguage}:`, error);
    throw new Error(`Failed to translate panels.`);
  }
};